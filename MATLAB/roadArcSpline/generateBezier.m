function [x, y, tangent,curvature] = generateBezier(P0,P1,P2,P3,P4,P5)

    t = 0:0.001:1;
    x = (1-t).^5 * P0(1) + 5*t.*(1-t).^4 * P1(1) + 10*t.^2.*(1-t).^3 * P2(1) + ...
        10*t.^3.*(1-t).^2 * P3(1) + 5*t.^4.*(1-t)*P4(1) + t.^5 * P5(1);
    
    y = (1-t).^5 * P0(2) + 5*t.*(1-t).^4 * P1(2) + 10*t.^2.*(1-t).^3 * P2(2) + ...
        10*t.^3.*(1-t).^2 * P3(2) + 5*t.^4.*(1-t)*P4(2) + t.^5 * P5(2);

    % Calculate first derivative
    dBx = 5*(1-t).^4*(P1(1)-P0(1)) + 20*(1-t).^3.*t*(P2(1)-P1(1)) + 20*(1-t).^2.*t.^2*(P3(1)-P2(1)) + ...
        20*(1-t).*t.^3*(P4(1)-P3(1)) + 5*t.^4*(P5(1)-P4(1));
    dBy = 5*(1-t).^4*(P1(2)-P0(2)) + 20*(1-t).^3.*t*(P2(2)-P1(2)) + 20*(1-t).^2.*t.^2*(P3(2)-P2(2)) + ...
        20*(1-t).*t.^3*(P4(2)-P3(2)) + 5*t.^4*(P5(2)-P4(2));
    dB = [dBx ; dBy]; 

    % Calculate second derivative
    ddBx = 20*(1-t).^3*(P2(1) - 2*P1(1) + P0(1)) + 60*(1-t).^2.*t*(P3(1) - 2*P2(1) + P1(1)) + ...
        60*(1-t).*t.^2*(P4(1) - 2*P3(1) + P2(1)) + 20*t.^3*(P5(1) - 2*P4(1) + P3(1)); 
    ddBy = 20*(1-t).^3*(P2(2) - 2*P1(2) + P0(2)) + 60*(1-t).^2.*t*(P3(2) - 2*P2(2) + P1(2)) + ...
        60*(1-t).*t.^2*(P4(2) - 2*P3(2) + P2(2)) + 20*t.^3*(P5(2) - 2*P4(2) + P3(2)); 

   cross_product = dBx.*ddBy - dBy.*ddBx; % cross(dB,ddB); 
   curvature = cross_product./vecnorm(dB,2,1).^3; 
   tangent = dB';
end